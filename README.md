DSA Foundation Roadmap
Phase 1: Basic Foundations 
Focus on solidifying Array, String, and basic Math/Logic problems. Aim to solve 1-2 from each category daily.

Data Structures: Arrays & Strings

Arrays:

Basic (from your list, try again if not 100% confident):

Max Element in Array

Number Distribution

Reverse Array

Odd and Even Sum

Mean Median Mode

Slightly More Challenging (from your list):

The Missing Number

Find Duplicate Number in Array

First and Last

Unique Elements

Merge Two Sorted Arrays

Intersection of Arrays

Print Array A Using B

Left Sum and Right Sum

New for Practice:

Rotate Array (various methods: Juggling Algorithm, Reversal Algorithm)

Subarray Sum (find if a subarray with a given sum exists)

Kadane's Algorithm (Maximum Subarray Sum)

Two Sum (find two numbers that add up to a target)

Move Zeros to End

Strings:

Basic (from your list):

Reverse String

Odd Even Index

Toggle Case

Vowels and Consonants

Slightly More Challenging (from your list):

Check the Square String

Digit String

Digits Sum

New for Practice:

Check for Palindrome (string and number)

Anagram Check

Implement strrev, strlen, strcpy

First Non-Repeating Character

Remove Duplicates from String

Longest Common Prefix

Algorithms: Basic Math & Logic

Math & Logic:

Basic (from your list):

Triangle Validator

Area of Rectangle

Arithmetic Operators

Arithmetic Progression

Nth Term of GP

Compute A power B

Number Reverse

Fibonacci Number

Factorial

Leap Year

Natural Numbers Sum

Digit Cubes

Harshad Numbers

Slightly More Challenging (from your list):

Catalan Number

NcR Basic

Applying Modulus

Factorial Hard

Minimum Subtraction

Number of Multiples

A B and X

Narcissistic Numbers

Compound Interest

Quadratic Equation

Prime or Not

Arrange Primes

New for Practice:

GCD and LCM

Prime Factorization

Sieve of Eratosthenes (for finding primes up to N)

Count Set Bits

Binary to Decimal / Decimal to Binary conversion

Phase 2: Intermediate Data Structures & Algorithms (Approx. 4-8 weeks)
Once comfortable with Phase 1, move to these. Focus on understanding the internal working of these data structures.

Data Structures: Linked Lists, Stacks, Queues, Hash Maps, Trees

Linked Lists:

Implement Singly Linked List (insertion, deletion, traversal)

Reverse a Linked List

Detect Cycle in Linked List

Merge Two Sorted Linked Lists

Find Middle of Linked List

Remove Nth Node from End

Implement Doubly Linked List (basics)

Stacks & Queues:

Implement Stack using Array/Linked List

Implement Queue using Array/Linked List

Balanced Parentheses

Implement Queue using two Stacks

Implement Stack using two Queues

Next Greater Element

Traverse a tree (DFS using stack, BFS using queue)

Hash Maps (Dictionaries/Hash Tables):

Implement basic Hash Map operations (put, get, remove)

Count Frequency of Elements

Two Sum (using hash map for efficiency)

Longest Substring Without Repeating Characters

Group Anagrams

Trees (Binary Trees):

Basic:

Traversals: Inorder, Preorder, Postorder (recursive and iterative)

Level Order Traversal (BFS)

Height/Depth of Binary Tree

Count Nodes

Check if Binary Tree is Symmetric

Slightly More Challenging:

Diameter of Binary Tree

Lowest Common Ancestor (LCA)

Mirror a Binary Tree

Construct Tree from Inorder and Preorder Traversals

Validate Binary Search Tree (BST)

Convert Sorted Array to BST

Algorithms: Sorting, Searching, Recursion, Backtracking

Sorting (from your list, ensure deep understanding):

Implement Bubble Sort

Implement Selection Sort

Implement Insertion Sort

Implement Shell Sort

Implement Merge Sort

New for Practice:

Implement Quick Sort

Heap Sort (requires understanding Heaps)

Searching (from your list, ensure deep understanding):

Implement Linear Search

Implement Binary Search

Recursion & Backtracking:

Factorial, Fibonacci (recursive implementations)

Tower of Hanoi

Generate all permutations of a string/array

N-Queens Problem

Sudoku Solver

Combinations Sum

Phase 3: Advanced Topics (Approx. 8+ weeks)
Only attempt these after a strong grasp of Phases 1 and 2.

Data Structures: Heaps, Graphs, Tries, Segment Trees, Fenwick Trees (BIT)

Heaps (Priority Queues):

Implement Min/Max Heap

Kth Largest/Smallest Element

Merge K Sorted Lists/Arrays

Top K Frequent Elements

Graphs:

Representations: Adjacency Matrix, Adjacency List

Graph Traversal: BFS, DFS

Topological Sort

Shortest Path Algorithms: Dijkstra's, Bellman-Ford

Minimum Spanning Tree: Prim's, Kruskal's

Detect Cycle in Undirected/Directed Graph

Number of Islands

Bipartite Check

Tries:

Implement Trie (Insert, Search, StartsWith)

Autocomplete/Prefix Searching

Advanced Trees:

AVL Trees (Introduction)

Red-Black Trees (Introduction)

Segment Trees (Range Query, Range Update)

Fenwick Trees (Binary Indexed Trees)

Algorithms: Greedy, Dynamic Programming, Bit Manipulation

Greedy Algorithms:

Activity Selection Problem

Coin Change Problem (greedy approach for specific coin sets)

Fractional Knapsack

Job Sequencing with Deadlines

Minimum Number of Coins (greedy if optimal)

Dynamic Programming (DP):

Basic DP (from your list):

Pascal's Triangle (can be solved with DP)

New for Practice:

Fibonacci (DP approach - memoization/tabulation)

Coin Change Problem (DP for optimal solution)

Knapsack Problem (0/1 Knapsack)

Longest Common Subsequence (LCS)

Longest Increasing Subsequence (LIS)

Edit Distance

Matrix Chain Multiplication

House Robber

Climbing Stairs

Bit Manipulation (from your list):

Check Bit

New for Practice:

Set/Clear/Toggle a Bit

Count Set Bits (various methods)

Power of 2 check

Swap two numbers without a temporary variable

Single Number (find unique element in array where others appear twice)